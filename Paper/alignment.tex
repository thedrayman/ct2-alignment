

\documentclass[conference]{IEEEtran}

\ifCLASSINFOpdf
   \usepackage[pdftex]{graphicx}
  \graphicspath{{../pdf/}{../jpeg/}}
\else
\fi

\usepackage{color,listings}
\usepackage{cite}

\lstset{language=[Sharp]C, % Grundsprache ist C und Dialekt ist Sharp (C#)
	captionpos=b, % Beschriftung ist unterhalb
	frame=lines, % Oberhalb und unterhalb des Listings ist eine Linie
	basicstyle=\ttfamily, % Schriftart
	keywordstyle=\color{blue}, % Farbe fÃ¼r die Keywords wie public, void, object u.s.w.
	commentstyle=\color{green}, % Farbe der Kommentare
	stringstyle=\color{red}, % Farbe der Zeichenketten
	numbers=left, % Zeilennummern links vom Code
	numberstyle=\tiny, % kleine Zeilennummern
	numbersep=5pt,
	breaklines=true, % Wordwrap a.k.a. Zeilenumbruch aktiviert
	showstringspaces=false,
	% emph legt Farben fÃ¼r bestimmte WÃ¶rter manuell fest
	emph={double,bool,int,unsigned,char,true,false,void},
	emphstyle=\color{blue},
	emph={Assert,Test},
	emphstyle=\color{red},
	emph={[2]\using,\#define,\#ifdef,\#endif}, emphstyle={[2]\color{blue}}
}

\usepackage{amsmath}
\usepackage{url}
\usepackage[disable]{todonotes}

%\usepackage{ngerman}
%\usepackage[latin1, utf8]{inputenc}
\usepackage[latin1]{inputenc}
%\usepackage[utf8x]{inputenc}

\hyphenation{op-tical net-works semi-conduc-tor}

\newcommand{\algoSW}{Smith-Waterman algorithm}


\begin{document}

\title{Location Prediction with Alignment Algorithm on Google Location Data}

\author{\IEEEauthorblockN{Olga Groh\IEEEauthorrefmark{1},
Johann G\"otz\IEEEauthorrefmark{2},
Fabian Fr\"olich\IEEEauthorrefmark{3}}
\IEEEauthorblockA{Faculty of Electrical Engineering and Computer Science\\
University of Kassel,\\
Kassel, Germany\\
Email: {\{\IEEEauthorrefmark{1}o\_groh, \IEEEauthorrefmark{2}uk017305, \IEEEauthorrefmark{3}f.fr\"olich\}@student.uni-kassel.de }}}
	

\maketitle

\begin{abstract}
	Nowadays, with the position history of a person, it's possible to predict the location where the person will be next. This approach is interesting in a wider field of application, such as rescue service, crime detection, advertising or personal smart-home systems. In this paper we try to predict a persons location with the Smith-Waterman alignment algorithm, which is commonly used in bioinformatics to compare segments of protein sequences. As data set we used Google's location history from different mobile devices. 
	
	Results::The \algoSW is the very best way to predict location with a wonderful runtime in real-time applications....
\end{abstract}
\begin{IEEEkeywords}location prediction;
	 alignment algorithm
\end{IEEEkeywords}

\IEEEpeerreviewmaketitle

\section{Introduction}\label{section:introduction}
\todo{
Das Wissen um die Position einer Person spielt in der heutigen, digitalen Welt eine wichtige Rolle. In allen denkbaren Bereichen kann eine genaue Position hilfreich sein oder gar Leben retten. Einen Schritt weiter geht die Positionsvorhersage, bei der der zukünfitige Aufenthaltsort einer Person bestimmt. Damit ergibt sich nicht nur das Wissen, wo die Person ist, sondern auch wo sie zu hoher Wahrscheinlichkeit als nächstes sein wird. Um die Bedeutung dieser Technologie ein wenig zu verdeutlichen, seien an dieser Stelle ein paar Szenarien beschrieben.

Ein lebensrettender Einsatz ist die Anwendung der Positionsbestimmung bzw. -vorhersage bei älteren Menschen. Ausgestattet mit den richtigen Geräten, ist es heute möglich den Gesundheitszustand einer Person zu erfassen und Aussagen über diese zu treffen. Abhängig von diesem Zustand kann dann bei einem Sturz oder einer Verschlechterung des Zustand Hilfe geholt werden. Dabei ist es womöglich sehr wichtig, wo sich die Person befindet. Über die Positionsbestimmung ist es möglich die Person zu finden - sofern diese Bestimmung aktuell ist. Über die Positionsvorhersage ist es zusätzlich möglich Aussagen über den Aufenthaltsort zu machen, auch wenn das Gerät der Positionsbestimmung vergessen wurde oder versagt.

Auch in anderen Gefahren- oder Rettungsszenarien ist die genaue Position hilfreich. Man stelle sich einen Unfall auf der Autobahn vor, dabei ist es für die Rettungskräfte von sehr großen Vorteil zu Wissen auf welcher der Straße sich der Unfall ereignet hat. Hierbei ist die exakte Bestimmung der Position wichtiger als die Vorhersage. Allerdings gibt es auch Situationen, da ist eine Vorhersage für die Rettungskräfte von Bedeutung. Als Beispiele seinen hier die Rettung von Wanderern bei schlechtem Wetter oder von Personen nach einer Naturkatastrophe genannt.

Weitere Situationen für die Wichtigkeit der Vorhersage von Positionen von Personen sind in der Verbrechensbekämpfung und -aufklärung denkbar. Für Unternehmen ist die Vorhersage ebenso ein wichtiges Instrument, lassen sich doch damit Werbeanzeigen personenbezogen anzeigen und verbreiten. Aber auch für eine Privatperson kann die Vorhersage der eigenen Position hilfreich sein, bedenkt man den steigenden Einsatz von Smart-Home-Technik. Mit Vorhersagen über die Position des Eigentümers, kann das heimische System wissen, wann die Person zu Hause eintrifft und somit die Heizung rechtzeitig einschalten.

All die genannten Szenarien sind abhängig von Positionsbestimmung und -vorhersage. Dabei ist es heutzutage kaum noch ein Problem die dazu benötigeten Daten zu erhalten. In den letzten zehn Jahren hat sich das Smartphone zu einem nützlichen und allseits mitgeführen Gefährten gemausert. Die Mächtigkeit des Begleiters wird trotzdem von den meisten unterschätzt. Mit den erfassten, und in den meisten Fällen gespeichterten Daten, lassen sich Aussagen über den Besitzer treffen.Es lässt sich gar ein ziemlich genaues persönliches Profil erstellen. Mit den erfassten Positionsdaten lässt sich, mit Hilfe der richtigen Algorithmen und Methoden, eine Positionsvorhersage erstellen. 

In dieser Arbeit wird versucht, eine Positionsvorhersage mit dem Ansatz des Alignments zu erstellen. Die dabei genutzten, aufgezeichneten Positionsdaten wurden vorab durch verschiedene Smartphones und Personen erfasst. Mit Hilfe der Daten und einem Alignment-Algorithmus werden wir versuchen die nächste Position vorherzusagen.
}
The knowledge about a person's location plays a very important role in today's digital world. An exact location in all imaginable areas can be helpful or even save lives. Another step forward is the prediction of the future location of a person. With that, one can not only acquire the information of the current location of said person and also determine with high probability where he/she will be located next. To further illustrate the meaning/importance of this technology, some likely scenarios will be presented in the following.

One life saving possibility using this technology, presents itself in relation to the elderly. Provided with the right devices, it is possible today to determine the state of health of a person and take action accordingly. Should this state take a turn for the worse or when the person has taken a fall, it can be possible to get the required help in time. In those situations the location of a person is of great importance. With the location ascertainment it will be possible to find the person with the correct latest location information. Furthermore, it will be possible using location ascertainment to predict the location even if the device is is left behind or if it malfunctions.

An exact location is helpful in other scenarios relating to danger and rescue as well. If one imagines an accident on the freeway, it is very important for the rescue to know the exact road on which the accident took place. In this case the exact position is more important than the prediction. However, there are several situations, where the possibility of location prediction plays a more important role. Some examples of that would be rescuing hikers stuck on the trail due to bad weather, or helping people after a natural disaster.
 
Additional importance for location ascertainment of people is in the field of crime fighting and -solving. It could also be profitable for companies because the use of this technology allows them to project and distribute personalized marketing in predetermined locations. But even a private user would find benefits in the determination of his/her location, when one bears in mind the constant rise in use of smart-home-technology. Using the location information of the user, the home system knows when he/she will be home and even the right time to turn on the heating.

All the scenarios described above are dependent on determining and predicting the location of a person. It is also not problematic to acquire the data needed for this in today's digital world. In the last ten years the Smartphone has proven itself to be a useful gadget and a permanent companion. But the power of this device is still underrated by most. With the gathered and in most cases also saved data, it is possible to make assumptions about the owner of the phone. Even more, it is possible to create a very detailed personal profile. With the gathered location data, using the right algorithms and methods, a position prediction becomes possible.

In the following, an attempt will be made to create a location prediction using alignment. The used positioning data was gathered in advance from various people and smartphones. Using this information and an alignment algorithm, an effort will be made to predict the next location.  

%Voraussage der Location von alten Menschen und rechtzeitiges Handeln, wenn sie sich nicht an der entsprechenden Position befinden (Verhalten)

%Locations werden oft Ã¼ber bestimmte Applikationen automatisch von Smartphones aufgezeichnet

%Anbieten von personenbezogener Werbung an den vorhergesagten Standort

%Smart-Home Bereich (Temperatur, Energiemanagement, Komfort)


\section{Related Work}\label{section:relatedWork}
\todo{
Zu Location Prediction gibt es eine Menge Forschungsmaterial.
Alignment Algorithmen bieten ein Ähnlichkeitsmaß für beliebige Folgen von Datenpunkten, auch Sequenzen genannt. Das heißt die Anwendung solcher Algorithmen ermöglicht es zwei Sequenzen auf ihre Ähnlichkeit zu untersuchen und somit zu Vergleichen. Eine häufige Anwendung findet in der Bioinformatik statt. Hierbei werden DNA- oder Protein-Sequenzen auf evolutionsbedingte Verwandtschaft untersucht. Ein Beispiel hierfür findet sich in \cite{waterman1995introduction}.

Sigg et al. \cite{sigg2010alignment} beschreiben einen Ansatz um mittels Alignment vorhersagen anhand von Kontextsequenzen machen zu können. Die Anwendung von Alignment Algorithmen ermöglicht es Sigg et al. die ähnlichsten vorkommende Teilsequenzen zu finden und anhand dieser den nächsten Eintrag vorhersagen zu können. Dafür verwenden sie unter anderem  Needleman-Wunsch-Algorithmus \cite{needleman1970general}, welcher mittels Backtracking ein globales Optimum findet. Ein Ähnlicher Algorithmus ist der Hirschberg-Algorithmus \cite{hirschberg1975linear}, welcher ebenfalls ein globaler Algorithmus ähnlich wie der Needleman-Wunsch-Algorithmus ist.

Unser Ansatz basiert ebenfalls auf Alignment Algorithmen. Dabei verwenden wir im Gegensatz zu \cite{sigg2010alignment} den Smith-Waterman-Algorithmus \cite{smith1981identification}
innerhalb unseres Location Prediction Ansatzes. Dieser Algorithmus ist im Gegensatz zum Needleman-Wunsch-Algorithmus und Hirschbergalgorithmus in der Lage das lokale Optimum zu finden. Dies hat den Vorteil, dass lokale Übereinstimmungen nicht wie bei einer globalen Betrachtung übersehen werden können.

Neben der Verwendung von Alignment Algorithmen gibt es weitere Ansätze zur Location Prediction. Craig et al. \cite{craig2017region} nutzen einen Clustering-Ansatz um Aufenthaltsorte einer Person mittels Cluster zu definieren. Dies geschieht, in dem ein Ort in möglichst kleine Regionen eingeteilt wird und anschließend ähnliche benachbarte Regionen zu größeren Clustern kombiniert werden. Basierend auf diesen Regionen ist das Ziel den nächsten Ort an dem sich eine Person befinden wird vorherzusagen. Dabei wird anhand des aktuellen bzw. der vorherigen Standorte geprüft auf welcher Strecke sicher der Nutzer befindet und Anhand dieser Information das Cluster bestimmt in welchem sein nächstes Ziel liegen könnte.
Im Gegensatz zu unseren Ansatz liefert Clustering keine optimale Lösung, sondern führt eine Reduktion der Daten durch und ermöglicht somit die Verwendung auf leistungsschwachen Geräten.

Rjeily et al. \cite{8167546} nutzen einen Sequenz Prediction Ansatz um ein Herzfehler eines Patienten festzustellen.
Dazu werden diskrete sowie kontinuierliche Datensequenzen verwendet, z.\,B.Schmerzen in der Brust auf einer Skala von 1 bis 4 und Blutdruckwerte. Dabei basiert Ihr Ansatz auf einer Erweiterung des Compact Prediction Tree Algorithmus \cite{gueniche2013compact}. Dieser Algorithmus ist in der Lage anhand einer gegebenen Sequenz das nächste Symbol zu schätzen, welches die Patienten zu Risikogruppen zuordnet. Die Sequenz wird dabei genutzt um zu überprüfen in welche Risikokategorie ein Patient eingestuft werden kann. Im Vergleich zu dem hier präsentierten Ansatz arbeitet der Algorithmus von Rjeily et al.auf komplexen hochdimensionalen Daten wodurch der Algorithmus zu komplex für die hier verwendeten Daten ist. Da sich die hier betrachteten Daten aus reinen diskreten Symbolen zusammensetzten, wäre die Anwendung eines solchen Algorithmus für unseren Ansatz ungeeignet.

Zusammenfassend findet Sequenzprediction eine breite Anwendung und eignet sich daher auch potentiell zu Verwendung von Location Prediction.

}

Plenty of research material exists for location prediction.
Alignment algorithms offer a similarity measure for arbitrary continuations of data points which are also called sequences. In other words the use for such algorithms allows us to check and compare the similarity of two sequences. Common adaptations often take place in bioinformatics. Here, DNA (Deoxyribonucleic acid) and protein sequences are being analyzed to determine evolution based relations. An example for this purpose can be found in \cite{waterman1995introduction}.

Sigg et al. \cite{sigg2010alignment} describe an approach where context sequences can be predicted by using alignment. The utilization of alignment algorithms allows Sigg et al. to find the most similar partial sequences and with the aid of these to predict the next entry. Among other things they use the Needleman-Wunsch algorithm \cite{needleman1970general} for that purpose which finds a global optimum by using the backtracking algorithm. A similar approach is the Hirschberg algorithm \cite{hirschberg1975linear} which is also a global algorithm similar to Needleman-Wunsch.

Our attempt is based on alignment as well. Unlike \cite{sigg2010alignment} we make use of the Smith-Waterman algorithm \cite{smith1981identification} within our location prediction approach. In contrast to the Needleman-Wunsch and the Hirschberg algorithm, this algorithm is able to find a local optimum. One benefit would be the fact, that local analogy can't be missed which is often the case with global consideration. 

Apart from the use of alignment algorithms there are two additional approaches for location prediction. Craig et al. \cite{craig2017region} use a clustering approach for defining whereabouts of one person trough clusters. This is done by deviding a location in preferably small regions and then combining similar adjacent regions to bigger clusters. Based on these regions the next objective is to predict the next location where a person will be situated. On the basis of the current or previous location the algorithm checks which route is the user is currently on. The cluster, which contains the user's next possible goal, is then determined with the aid of this information. Unlike our approach, clustering doesn't provide an optimal solution but rather it performs a reduction of data and thus enables the use for it on under-performing devices.

Rjeily et al. \cite{8167546} use a sequence prediction approach to detect a heart deficiency of a patient. For that to happen discrete and continuous data sequences are applied for example to determine the chest pain index from 1 to 4 and high blood pressure values. Therefore her approach is based on the compact prediction tree algorithm extension \cite{gueniche2013compact}. This algorithm is capable of estimating the next symbol of a given sequence which places the patients in a certain risk group. In doing so the sequence is used to check the ranking of the patient in a risk category. In comparison to this presented approach the algorithm of Rjeily et al. operates on complex high-dimensional data hence it is too sophisticated for our data. Because the data is composed of pure discrete symbols the application of such an algorithm would be unsuitable for our approach.

All in all the sequence prediction has several uses and potentially qualifies for location prediction.

\section{Conception}\label{section:conception} 

%Alignment wird normalerweise in der Biologie zum Vergleich von DNA-Sequenzen genutzt

%Wir nutzen Google Location Data, da Google es anbietet und fast jeder heutzutage ein Smartphone besitzt

%Alignment lÃ¤sst sich auf Location data anwenden

\todo{
Heutzutage besitzt fast jeder Mensch ein Smartphone.

Der Vorteil ist, dass die Daten bereits über Google Location Data \cite{37522} automatisch über eine Applikation aufgenommen werden, die auf Android-Systemen bereits bei einem Kauf des Geräts mitgeliefert wird. Die täglich aufgezeichneten Daten beinhalten genaue Positionskoordinaten und Zeiten bis hin zur Ortsbezeichnungen und Ortsgenauigkeiten.

Die hier genutzten Daten stammen aus dem Google Location-Projekt \cite{google-location} und liegen als .CSV-Datei vor, die auszugweise im folgenden Listing \ref{listing:exampledata}  dargestellt ist.

...

Für die Vorhersage der Location werden die einzelnen Datensätze der .CSV-Datei nach Zeit (\texttt{timestamp}) sortiert. Die Beschreibung (\texttt{description}) definiert den Ort des Nutzers anhand der Koordinaten (\texttt{logitude}, \texttt{latitude} und der Höhe \texttt{altitude}), während \texttt{accuracy} die Ortsgenauigkeit beschreibt. Für unseren Ansatz benötigen wird lediglich diese Beschreibung in der korrekten, zeitlichen Reihenfolge.

...

Die Idee ist es nun, den nächsten Ort einer Person anhand ihrer jetzigen und vergangenen Positionen vorherzusagen. Dafür betrachten wir die Daten als eine lange Sequenz, wie in Fig. \ref{fig:diagram} dargestellt. Aus ihr wird eine Suchsequenz mit den letzten \textit{x} Zeichen entnommen. Das Alignment wird nun auf der gesamten Sequenz und der Suchsequenz angewendet, um die ähnlichste lokale Sequenz zu finden. Alle Zeichen danach bilden die Vorhersagesequenz der Länge \textit{l}.

Der Algorithmus, der sich für dieses Problem am besten eignet, ist der \algoSW-Algorithmus, da er auf unterschiedlich lange Sequenzen angewendet werden kann, um lokal den kleinst möglichen Match zu finden. Ein anderer Vorteil ist, dass die Sequenzen nicht identisch sein müssen, sodass ebenfalls auch ähnliche Sequenzen gefunden werden können. Algorithmen wie Needleman-Wunsch und Hirschberg eignen sich dafür weniger, da diese nur global die größte, ähnlichste Sequenz aus den beiden Sequenzen errechnet.

Der \algoSW ist ein lokaler Optimierungsalgorithmus, der auf zwei Zeichenketten-Sequenzen arbeitet. Im ersten Schritt werden beide Sequenzen so angeordnet, dass sie eine Matrix bilden, von denen die erste Spalte und Zeile jeweils mit Nullen initialisiert wird. Jedes Zeichen aus Sequenz A wird mit jedem Zeichen aus Sequenz B iterativ, beginnend mit dem ersten Index in der Matrix, verglichen. Anhand von Rekurrenzen wird dann ein Ähnlichkeitsmaß (Score) berechnet. Handelt es sich beispielsweise um einen Match, so erhöht sich der Score um einen festgelegten Rekurrenzwert. Analog dazu verringert sich der Score dementsprechend. Ebenso kann es passieren, dass die Sequenzen zwar ähnlich, aber durch eine Lücke nicht mehr identisch sind. Bei einer Lücke handelt es sich entweder um eine Insertion oder eine Deletion in der Sequenz. Die nächsten Einträge werden genauso in Abhängigkeit vom vorherigen Wert berechnet. Im Gegensatz zum Needleman-Wunsch-Algorithmus kann der Eintrag in der Matrix beim \algoSW-Algorithmus nicht negativ sein. Sollte er jedoch in den negativen Bereich fallen, wird der Wert wieder auf Null gesetzt. Anschließend sucht man nach dem höchsten Wert in der gesamten Matrix. Dies ist der optimale Wert. Ein Alignment ist dann optimal, sobald es solch einen Wert besitzt. Eine Matrix kann mehrere Maxima haben, daher kann das Alignment an mehreren Stellen optimal sein. 

Im zweiten Schritt, wie in \ref{fig:watermansmith} zu erkennen, werden die entsprechenden ähnlichsten Stellen anhand des Traceback-Algorithmus erfasst. Ausgehend vom maximalen Wert wird der Berechnungspfad rückwärts diagonal nach Nord-Westen auf den Wert Null ausgeschlossen zurückverfolgt. Daraus ergeben sich Indizes für Start und Ende der Match-Sequenz.

}

Nowadays, almost anybody is using a mobile device with a GPS (Global Positioning System) on-board. 

The benefit of it is that google location data \cite{37522} is recorded automatically by programs that are already included in all android systems upon buying the device. The daily logged data contain accurate position coordiantes and timestamps right up to location names and inaccuracies.

\begin{table}[h]
	\caption{Example of collected Google Location Data}
	\resizebox{0.49\textwidth}{!}{%home:700, work:500, friend:800, sport:300
		\begin{tabular}{l*{4}{c}r}
			timestamp & accuaracy & longitude & latitude & altitude & unknown \\ 
			\hline		
			1300000000 & 30 & 9.500.700 & 51.330.700 & 0 & Home \\ 
			1299999800 & 31 & 9.500.700 & 51.330.700 & 0 & Home \\ 
			1299999600 & 31 & 9.500.300 & 51.330.300 & 0 & Sport \\ 
			1299999400 & 31 & 9.500.700 & 51.330.700 & 0 & Home \\ 
			1299999200 & 31 & 9.500.800 & 51.330.800 & 0 & Friend \\ 
			1299999000 & 32 & 9.500.800 & 51.330.800 & 0 & Friend \\ 
			1299998800 & 32 & 9.500.700 & 51.330.700 & 0 & Home \\ 
			1299998600 & 31 & 9.500.500 & 51.330.500 & 0 & Work \\ 
			1299998400 & 30 & 9.500.500 & 51.330.500 & 0 & Work \\ 
			1299998200 & 31 & 9.500.700 & 51.330.700 & 0 & Home \\ 
	\end{tabular}}
	\label{fig:csv}
\end{table}

The data originates from the google location project \cite{google-location} and is available as a .csv file that is represented in extracts in the following Table \ref{fig:csv}.

For location prediction individual datasets of the .csv file are sorted by the \texttt{timestamp}. The \texttt{description} defines the location of the user by the \texttt{logitude}, \texttt{latitude} and \texttt{altitude} coordinates while the \texttt{accuracy} describes the precision of the location. For our approach we need merely the description in a correct and chronological order.

%Idee der Implementierung und Grund für die Entscheidung

\begin{figure}[h]
	\centering
	\includegraphics[width=0.49\textwidth]{images/alignment_diagram5.pdf}
	\caption{Concept of sequence alignment and prediction}
	\label{fig:diagram}
\end{figure}

The idea now is to predict the next location of a person with the previous location data. Now we consider the data as a long sequence like depicted in Fig. \ref{fig:diagram}. Then a search sequence with the last \textit{x} characters is extracted from it. Finally the alignment is applied to the entire sequence to find the most similar local sequence. All characters after it form the prediction sequence of length \textit{l}.

The algorithm that is suited best for this kind of problem is the \algoSW algorithm because it can be utilized on sequences with different lengths to find the smallest possible match locally. Another benefit is that the sequences musn't be identical so that even similar sequences can be found as well. Algorithms like Needleman-Wunsch and Hirschberg are not suitable for it because those can only calculate the biggest, most similar sequence globally.

%Erklärung Waterman-Smith

\algoSW is a local optimization algorithm which operates on two character string sequences. First, both sequences are arranged in a way that they form a matrix so that its columns and rows are initialized with zeroes. Beginning with the first index in the matrix, every character from sequence A is compared iteratively to every character from sequence B. Then, with the help of reccurency values, a similarity score is calculated. If two characters match, then the score is increased by a fixed reccurency value. The score decreases accordingly if the characters don't match. Likewise it can happen that the sequences are indeed similar but by a gap no longer identical. During a gap situation in a sequence it is either the case of insertion or deletion. The next entries are equally calculated dependent on the previous value. Unlike in the Needleman-Wunsch algorithm, the matrix entry in the \algoSW algorithm cannot be nagative. However, if the entry falls into the negative section, its value is then set to zero. After that the algorithm looks for the highest value in the entire matrix. This is the optimal value. Alignment is optimal if and only if it contains such a value. A matrix can posses multiple maxima therefore the alignment can be optimal in several spots.

Next, the respective most similar characters are ascertained by the traceback algorithm. Based on the maximum value the path is then traced back diagonally to the north west, exclussively up until the value zero. At last, the indices result from the alignment of start and end positions of the match sequence.

\subsection{Example}

\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{images/watermansmith.jpg}
	\caption{Filled-in Smith-Waterman table with traceback\cite{ibm}}
	\label{fig:watermansmith}
\end{figure}

To illustrate the use of the algorithm we consider two sequences aligned, like shown in \ref{fig:watermansmith}.

\begin{enumerate}
\item The first column and row of the matrix should be initialized with zeroes.
\item Beginning with the first index (0,0) the score is calculated iteratively with the help of reccurencies. The score for (G,G) results in the value 1, because there is a match, whereas for (G,C) it results in 0, because the characters don't match (so the reccurency is -1) and because the value is now negative, it is set to 0 according to the algorithm rule.
\item If the matrix is calculated completely, the highest value, in this case it is 3, is found.
\item Now, the traceback algorithm searches for the right path backwards diagonally to the north west until the value 0. As of now, the path has the length of 4. As said before, the calculated value 0 does not count. That means the path length is 3.
\item By reading from the matrix the result for the local alignment is indeed "{}GCG"{}.
\end{enumerate}

\section{Implementation}\label{section:implementation}

\todo{

Wie in Kapitel \ref{section:conception} bereits erklärt, benötigen wir für das Alignment aus den Daten nur den timestamp und die Ortsbezeichnungen.

Die Daten der CSV-Datei sind durch Semikolons voneinander getrennt. Beim Einlesen wird die Header-Zeile zunächst übersprungen. Aus den Zeilen werden Ortsbezeichnungen entnommen und anhand des timestamps sortiert. Während des zeilenweisen Einlesens werden den Orten jeweils ein Buchstabe aus dem Alphabet zugeordnet. Dies ist nötig, da die Implementierung des Algorithmuses zur Berechnung ein einzelnes Zeichen erwartet - Anpassungen und Optimierungen auf Zeichenketten als Ortsbezeichnung sind durchführbar. Um Dopplungen zu vermeiden, wird nicht der erste Buchstaben der Ortsbezeichnung als Zeichen genutzt, sondern ein vorab definierter Buchstabe. Diese Zeichenkette ist anhand des Zeitstempels sortiert und bildet die sogenannte \textit{History-Sequenz}.

Die Implementierung nutzt zwei Arten der History-Sequenz Darstellung - die komplette Zeichenkette der Ortsbezeichnung und eine zusammengefasste. Bei der ersten Darstellung, werden alle zu Verfügung stehenden, aufgezeichneten Daten in die History-Sequenz übernommen. Die zusammengefasste Darstellung fast Dateneinträge anhand von Zeitintervallen zusammen. Dabei wird die Sequenz Zeichen für Zeichen eingelesen und überprüft, ob sich aufeinanderfolgende die Zeichen zusammenfassen lassen. Das hier gewählte Zeitintervall beträgt 30 Minuten. Sollte sich innerhalb dieses Intervalls das Zeichen nicht ändern, so wird dieses ignoriert. Folgt auf das betrachtet Zeichen ein anderes ( Ortswechsel) wrid dieses Zeichen in den komprimierte Sequenz aufgenommen. Ist das nachfolgende Zeichen gleich, aber dasZeitintervall wird überschritten, verbleibt das Zeichen in der Sequenz. Hier wird ein längerer Aufenthalt an einem Ort dargestellt. Durch die Komprimierung erhält man eine deutlich kürzere Sequenz, was in der nachfolgenden Tabelle \ref{tab:compression} detailiert dargestellt ist.

...

Im nächsten Schritt werden \textit{x} Zeichen am Ende der History-Sequenz als Suchsequenz definiert. Nun werden beide Sequenzen an den Smith-Waterman-Algorithmus übergeben, damit er aus ihnen eine Score-Matrix berechnen kann. In unserem Programm arbeitet der Algorithmus auf den Rekurrenzen \textit{match=2}, \textit{mismatch=-1} und \textit{gap=-1}. Als Ausgabe wird eine Matrixzelle mit dem höchsten Score und mit den Indizes der gefundenen lokalen Sequenz erwartet, sodass man direkt auf die Stelle in der History-Sequenz zugreifen kann. Gibt es mehrere höchste Scores, so wird der zuerst gefundene genommen. Alle Zeichen mit der gewählten Länge \textit{l} können nun aus der History-Sequenz abgelesen werden.

...

}

%Implementierung prediction

Like in Chapter \ref{section:conception} already explained, we require for alignment only timestamps and descriptions from the data.

The data from the csv. file is seperated by semicolons from each other. While reading the data, the header line is initially skipped. Descriptions are extracted from the lines and then sorted by the timestamps. During the row-wise reading each location name is assigned to a different character from the alphabet. This is necessary because the implementation of the algorithm expects one particular character for the calculation. Adjustments and Optimization on strings for location name are also viable. To avoid duplicates, the first character from the location name is not used but rather a beforehand defined character. This character string is sorted by timestamps and it forms a so-called \textit{history sequence}.

The implementation uses two types of depiction of the history sequence - the entire character string of location names and the summarized. In the first depiction all available, recorded data in the history sequence is carried over. The summarized depiction summarizes all data entries based on time intervals. When each character is imported, the algorithm checks wheter the sequent characters can be summarized. Here, the chosen time interval is 30 minutes. Within this time interval, if the character doesn't change it will be ignored. If another character (location change) follows after a considered one then this character is included in a compressed sequence. Is the subsequent character equal but the time interval is exceeded, the character remains in the sequence. Here, a long-term stay in one location is pictured. By applying the compression we obtain a clearly shoter sequence which is presented in-depth in the following Table \ref{tab:compression}.

\begin{table}[h]
	\centering
	\caption{Comparison uncompressed and compressed history sequence}
	\begin{tabular}{cccc}
		Data set & uncompressed & compressed & reduction \\
		\hline
		Sequence 1 & 1858 & 436 & 76,53\% \\
		Sequence 2 & 5499 & 1015 & 81,54\% \\
		Sequence 3 & 2222 & 581 & 73,85\% \\
	\end{tabular}
	\label{tab:compression}
\end{table}

The next step will be to define \textit{x} characters at the end of the history sequence. Now, both sequences are handed over to the \algoSW algorithm in order to compute the score matrix. In our program, the algorithm operates on the reccurencies \textit{match=2}, \textit{mismatch=-1} and \textit{gap=-1}. A matrix cell with the highest score and with the indices of the found local sequence is expected as output so that we can  get the values of the history sequence directly. If the matrix contains more than one highest score, the first found one is taken. All the characters with the selected length \textit{l} can now be read off the history sequence.

%Beispiel prediction

\subsection{Example}

Let us assume that the exctract from a .csv file consists of unsorted data like shown in Table \ref{fig:csv}. After the ..

\begin{table}[h]
	\centering
	\caption{Sorted, usable Google Location Data}
	\begin{tabular}{{c}r}
		timestamp & unknown \\ 
		\hline
		1299998200 & Home \\ 
		1299998400 & Work \\ 
		1299998600 & Work \\
		1299998800 & Home \\ 
		1299999000 & Friend \\
		1299999200 & Friend \\  
		1299999400 & Home \\
		1299999600 & Sport \\ 
		1299999800 & Home \\ 
		1300000000 & Home \\  
	\end{tabular}
	\label{fig:csv_sorted}
\end{table}

\begin{figure}
	\[Home \rightarrow A, Work \rightarrow B, Friend \rightarrow C, Sport \rightarrow D\]
	\caption{Example of location data mapping}
	\label{fig:csv_converted}
\end{figure}

%Implementierung test

%Sie wird an einer bestimmten Stelle - üblicherweise in der Mitte - zu einer History- und einer Testsequenz gespalten. Somit entsteht eine Historysequenz, die abrupt endet und deren \textit{l} Zeichen man vorhersagen kann. Nun wird der Historysequenz eine Suchsequenz mit den letzten \textit{x} Zeichen entnommen. Das Alignment wird dann auf die Test- und Suchsequenz angewendet, um die ähnlichste Sequenz zu finden. Alle Zeichen danach bilden die Vorhersagesequenz.

\section{Evaluation}\label{section:evaluation}
Es wurden uns Daten von drei unterschiedlichen Personen bereitgestellt, die jeweils einen Zeitraum von einem Monat bis hin zu mehreren Monaten aufweisen.

Um die Genauigkeit der Vorhersage zu evaluieren, versuchen wir auf den vorhandnen Daten Vorhersagen zu machen und diese mit den vorliegenden Datensatz zu vergleichen. Dazu nutzen wir die letzten \textit{x} Daten als Test-Sequenz, welcher wir eine Such-Sequenz entnehmen. Folglich bilden die übrigen Daten die History-Sequenz. Die an die Such-Sequenz anschließenden \textit{y} Zeichen definieren wir als zu \textit{erwartende Vorhersage}. Nun wenden wir unser Programm auf die Such- und History-Sequenz an. Wird eine Vorhersage gefunden, wird diese mit der erwartenden Vorhersage verglichen. Dieses Evlauationsverfahren ist auf Abbildung \ref{fig:diagram_test} dargestellt.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.49\textwidth]{images/alignment_diagram6.pdf}
	\caption{Concept of prediction sequence testing}
	\label{fig:diagram_test}
\end{figure}

Betrachtet wird außerdem die Auswirkklung der Länge der Such-Sequenz \textit{k} und der Länge der Vorhersage \textit{l}. Dabei fällt auf, dass

\begin{figure}[h]
	\centering
	\includegraphics[width=0.49\textwidth]{images/evaluation_uncompressed.pdf}
	\caption{Predicted values from original sequence}
	\label{fig:diagram_test}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.49\textwidth]{images/evaluation_compressed.pdf}
	\caption{Predicted values from the summarized 30 minutes sequence}
	\label{fig:diagram_test}
\end{figure}

%Wie schnell ist der Algorithmus auf groÃŸen Daten?

%LÃ¤nge der Vergleichssequenz

%Nutzbarkeit für Real-Time-Anwendung


\section{Conclusion}\label{section:conclusion}

%Erneute Zusammenfassung der Ergebnisse
\todo{Den nächsten Standort einer Person vorhersagen zu können ist für viele Anwendungen hilfreich. Ein Beispiel für eine solche Anwendung findet sich im medizinischen Bereich. Hierbei könnte die Location Prediction besonders hilfreich bei der Detektion von Stürzen von älteren Personen sein. Weicht eine ältere Person mehrfach signifikant von der Vorhersage ab, könnte dies darauf hindeuten, dass sie Hilfe benötigt.

Wir haben Daten von der Google Location History von verschiedenen Nutzern entnommen und versucht eine Vorhersage über die nächsten Standorte zumachen. Dazu haben wir einen Alginment Ansatz verwendet. Die Daten haben wir zu einer Sequenz umgewandelt und mit dem Smith-Waterman-Algorithmus haben wir eine mögliche Weiterführung der Sequenz durchgeführt.
%Was ist dabei herausgekommen?

%Was kÃ¶nnte man noch machen?
In der Zukunft wollen wir unseren Ansatz noch dahingehend verbessern das wir unser Programm besser auf Echtzeitanwendungen abstimmen wollen und das die Daten direkt aus der Google Location History entnommen werden. Eine mögliche Anwendung ist die Nutzung der Location Prediction im Bereich von Smart Home. Anhand des prädizierten Aufenthaltsorts des Nutzers könnten beispielsweise die Heizung oder die Kaffeemaschine eingeschaltet werden. 
}

The ability to predict a person's next location is beneficial to many applications. An example for such kind of application can be found in a medical environment. In this case, location prediction could be particularly  helpful in detecting falls of elderly persons. If an older persons behaviour significantly differs from the prediction on several occasions, it could indicate that the person needs help.

The presented approach collected Google Location History data from several users. Based on this, our approach was to predict the next location of a user by applying alignment techniques. Therefore, we converted the data into a sequence and with the \algoSW\ we tried to determine a possible continuation of the sequence.
%Hier noch ergebnisse von evaluation beschreiben

In our future work, we want to improve the performance of our approach in order to use it in real-time applications. Furthermore, we want to extract the data directly from Google Location History. One possible application is the use of our approach in the Smart Home environment. Based on the user's predicted location the heater or coffee machine could be automatically turned on at a certain time.

%\newpage
\bibliographystyle{IEEEtran}
\bibliography{alignment}


\end{document}


